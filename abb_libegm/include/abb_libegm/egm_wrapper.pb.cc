// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#include "egm_wrapper.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace abb {
namespace egm {
namespace wrapper {
class HeaderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Header>
      _instance;
} _Header_default_instance_;
class StatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Status>
      _instance;
} _Status_default_instance_;
class JointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Joints>
      _instance;
} _Joints_default_instance_;
class JointSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<JointSpace>
      _instance;
} _JointSpace_default_instance_;
class CartesianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Cartesian>
      _instance;
} _Cartesian_default_instance_;
class EulerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Euler>
      _instance;
} _Euler_default_instance_;
class QuaternionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Quaternion>
      _instance;
} _Quaternion_default_instance_;
class CartesianPoseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianPose>
      _instance;
} _CartesianPose_default_instance_;
class CartesianVelocityDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianVelocity>
      _instance;
} _CartesianVelocity_default_instance_;
class CartesianSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianSpace>
      _instance;
} _CartesianSpace_default_instance_;
class RobotDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Robot>
      _instance;
} _Robot_default_instance_;
class ExternalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<External>
      _instance;
} _External_default_instance_;
class FeedbackDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Feedback>
      _instance;
} _Feedback_default_instance_;
class PlannedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Planned>
      _instance;
} _Planned_default_instance_;
class InputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Input>
      _instance;
} _Input_default_instance_;
class OutputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Output>
      _instance;
} _Output_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace protobuf_egm_5fwrapper_2eproto {
void InitDefaultsHeaderImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Header_default_instance_;
    new (ptr) ::abb::egm::wrapper::Header();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Header::InitAsDefaultInstance();
}

void InitDefaultsHeader() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsHeaderImpl);
}

void InitDefaultsStatusImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Status_default_instance_;
    new (ptr) ::abb::egm::wrapper::Status();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Status::InitAsDefaultInstance();
}

void InitDefaultsStatus() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsStatusImpl);
}

void InitDefaultsJointsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Joints_default_instance_;
    new (ptr) ::abb::egm::wrapper::Joints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Joints::InitAsDefaultInstance();
}

void InitDefaultsJoints() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsJointsImpl);
}

void InitDefaultsJointSpaceImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsJoints();
  {
    void* ptr = &::abb::egm::wrapper::_JointSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::JointSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::JointSpace::InitAsDefaultInstance();
}

void InitDefaultsJointSpace() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsJointSpaceImpl);
}

void InitDefaultsCartesianImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Cartesian_default_instance_;
    new (ptr) ::abb::egm::wrapper::Cartesian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Cartesian::InitAsDefaultInstance();
}

void InitDefaultsCartesian() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCartesianImpl);
}

void InitDefaultsEulerImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Euler_default_instance_;
    new (ptr) ::abb::egm::wrapper::Euler();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Euler::InitAsDefaultInstance();
}

void InitDefaultsEuler() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEulerImpl);
}

void InitDefaultsQuaternionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::wrapper::_Quaternion_default_instance_;
    new (ptr) ::abb::egm::wrapper::Quaternion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Quaternion::InitAsDefaultInstance();
}

void InitDefaultsQuaternion() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsQuaternionImpl);
}

void InitDefaultsCartesianPoseImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesian();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsEuler();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsQuaternion();
  {
    void* ptr = &::abb::egm::wrapper::_CartesianPose_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianPose();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianPose::InitAsDefaultInstance();
}

void InitDefaultsCartesianPose() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCartesianPoseImpl);
}

void InitDefaultsCartesianVelocityImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesian();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsEuler();
  {
    void* ptr = &::abb::egm::wrapper::_CartesianVelocity_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianVelocity();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianVelocity::InitAsDefaultInstance();
}

void InitDefaultsCartesianVelocity() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCartesianVelocityImpl);
}

void InitDefaultsCartesianSpaceImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianPose();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianVelocity();
  {
    void* ptr = &::abb::egm::wrapper::_CartesianSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianSpace::InitAsDefaultInstance();
}

void InitDefaultsCartesianSpace() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCartesianSpaceImpl);
}

void InitDefaultsRobotImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsJointSpace();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianSpace();
  {
    void* ptr = &::abb::egm::wrapper::_Robot_default_instance_;
    new (ptr) ::abb::egm::wrapper::Robot();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Robot::InitAsDefaultInstance();
}

void InitDefaultsRobot() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRobotImpl);
}

void InitDefaultsExternalImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsJointSpace();
  {
    void* ptr = &::abb::egm::wrapper::_External_default_instance_;
    new (ptr) ::abb::egm::wrapper::External();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::External::InitAsDefaultInstance();
}

void InitDefaultsExternal() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsExternalImpl);
}

void InitDefaultsFeedbackImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsRobot();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsExternal();
  {
    void* ptr = &::abb::egm::wrapper::_Feedback_default_instance_;
    new (ptr) ::abb::egm::wrapper::Feedback();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Feedback::InitAsDefaultInstance();
}

void InitDefaultsFeedback() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsFeedbackImpl);
}

void InitDefaultsPlannedImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsRobot();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsExternal();
  {
    void* ptr = &::abb::egm::wrapper::_Planned_default_instance_;
    new (ptr) ::abb::egm::wrapper::Planned();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Planned::InitAsDefaultInstance();
}

void InitDefaultsPlanned() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsPlannedImpl);
}

void InitDefaultsInputImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsHeader();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsFeedback();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsPlanned();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsStatus();
  {
    void* ptr = &::abb::egm::wrapper::_Input_default_instance_;
    new (ptr) ::abb::egm::wrapper::Input();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Input::InitAsDefaultInstance();
}

void InitDefaultsInput() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsInputImpl);
}

void InitDefaultsOutputImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_5fwrapper_2eproto::InitDefaultsRobot();
  protobuf_egm_5fwrapper_2eproto::InitDefaultsExternal();
  {
    void* ptr = &::abb::egm::wrapper::_Output_default_instance_;
    new (ptr) ::abb::egm::wrapper::Output();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Output::InitAsDefaultInstance();
}

void InitDefaultsOutput() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsOutputImpl);
}

::google::protobuf::Metadata file_level_metadata[16];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[4];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, sequance_number_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, time_stamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, message_type_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_convergence_met_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, motor_state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, rapid_execution_state_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, values_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, velocity_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u0_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u2_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u3_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, euler_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, quaternion_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, linear_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, angular_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, pose_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, velocity_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, joints_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, cartesian_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, joints_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, external_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, external_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, feedback_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, planned_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, status_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, external_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::abb::egm::wrapper::Header)},
  { 11, 20, sizeof(::abb::egm::wrapper::Status)},
  { 24, 30, sizeof(::abb::egm::wrapper::Joints)},
  { 31, 38, sizeof(::abb::egm::wrapper::JointSpace)},
  { 40, 48, sizeof(::abb::egm::wrapper::Cartesian)},
  { 51, 59, sizeof(::abb::egm::wrapper::Euler)},
  { 62, 71, sizeof(::abb::egm::wrapper::Quaternion)},
  { 75, 83, sizeof(::abb::egm::wrapper::CartesianPose)},
  { 86, 93, sizeof(::abb::egm::wrapper::CartesianVelocity)},
  { 95, 102, sizeof(::abb::egm::wrapper::CartesianSpace)},
  { 104, 111, sizeof(::abb::egm::wrapper::Robot)},
  { 113, 119, sizeof(::abb::egm::wrapper::External)},
  { 120, 127, sizeof(::abb::egm::wrapper::Feedback)},
  { 129, 136, sizeof(::abb::egm::wrapper::Planned)},
  { 138, 147, sizeof(::abb::egm::wrapper::Input)},
  { 151, 158, sizeof(::abb::egm::wrapper::Output)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Header_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Status_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Joints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_JointSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Cartesian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Euler_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Quaternion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianPose_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianVelocity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Robot_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_External_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Feedback_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Planned_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Input_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Output_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "egm_wrapper.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 16);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\021egm_wrapper.proto\022\017abb.egm.wrapper\"\243\001\n"
      "\006Header\022\027\n\017sequance_number\030\001 \001(\r\022\022\n\ntime"
      "_stamp\030\002 \001(\r\022D\n\014message_type\030\003 \001(\0162#.abb"
      ".egm.wrapper.Header.MessageType:\tUNDEFIN"
      "ED\"&\n\013MessageType\022\r\n\tUNDEFINED\020\000\022\010\n\004DATA"
      "\020\001\"\366\003\n\006Status\022\033\n\023egm_convergence_met\030\001 \001"
      "(\010\022B\n\tegm_state\030\002 \001(\0162 .abb.egm.wrapper."
      "Status.EGMState:\rEGM_UNDEFINED\022I\n\013motor_"
      "state\030\003 \001(\0162\".abb.egm.wrapper.Status.Mot"
      "orState:\020MOTORS_UNDEFINED\022[\n\025rapid_execu"
      "tion_state\030\004 \001(\0162+.abb.egm.wrapper.Statu"
      "s.RAPIDExecutionState:\017RAPID_UNDEFINED\"N"
      "\n\010EGMState\022\021\n\rEGM_UNDEFINED\020\000\022\r\n\tEGM_ERR"
      "OR\020\001\022\017\n\013EGM_STOPPED\020\002\022\017\n\013EGM_RUNNING\020\003\"A"
      "\n\nMotorState\022\024\n\020MOTORS_UNDEFINED\020\000\022\r\n\tMO"
      "TORS_ON\020\001\022\016\n\nMOTORS_OFF\020\002\"P\n\023RAPIDExecut"
      "ionState\022\023\n\017RAPID_UNDEFINED\020\000\022\021\n\rRAPID_S"
      "TOPPED\020\001\022\021\n\rRAPID_RUNNING\020\002\"\030\n\006Joints\022\016\n"
      "\006values\030\001 \003(\001\"b\n\nJointSpace\022)\n\010position\030"
      "\001 \001(\0132\027.abb.egm.wrapper.Joints\022)\n\010veloci"
      "ty\030\002 \001(\0132\027.abb.egm.wrapper.Joints\",\n\tCar"
      "tesian\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\""
      "(\n\005Euler\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001("
      "\001\"<\n\nQuaternion\022\n\n\002u0\030\001 \001(\001\022\n\n\002u1\030\002 \001(\001\022"
      "\n\n\002u2\030\003 \001(\001\022\n\n\002u3\030\004 \001(\001\"\225\001\n\rCartesianPos"
      "e\022,\n\010position\030\001 \001(\0132\032.abb.egm.wrapper.Ca"
      "rtesian\022%\n\005euler\030\002 \001(\0132\026.abb.egm.wrapper"
      ".Euler\022/\n\nquaternion\030\003 \001(\0132\033.abb.egm.wra"
      "pper.Quaternion\"h\n\021CartesianVelocity\022*\n\006"
      "linear\030\001 \001(\0132\032.abb.egm.wrapper.Cartesian"
      "\022\'\n\007angular\030\002 \001(\0132\026.abb.egm.wrapper.Eule"
      "r\"t\n\016CartesianSpace\022,\n\004pose\030\001 \001(\0132\036.abb."
      "egm.wrapper.CartesianPose\0224\n\010velocity\030\002 "
      "\001(\0132\".abb.egm.wrapper.CartesianVelocity\""
      "h\n\005Robot\022+\n\006joints\030\001 \001(\0132\033.abb.egm.wrapp"
      "er.JointSpace\0222\n\tcartesian\030\002 \001(\0132\037.abb.e"
      "gm.wrapper.CartesianSpace\"7\n\010External\022+\n"
      "\006joints\030\001 \001(\0132\033.abb.egm.wrapper.JointSpa"
      "ce\"^\n\010Feedback\022%\n\005robot\030\001 \001(\0132\026.abb.egm."
      "wrapper.Robot\022+\n\010external\030\002 \001(\0132\031.abb.eg"
      "m.wrapper.External\"]\n\007Planned\022%\n\005robot\030\001"
      " \001(\0132\026.abb.egm.wrapper.Robot\022+\n\010external"
      "\030\002 \001(\0132\031.abb.egm.wrapper.External\"\261\001\n\005In"
      "put\022\'\n\006header\030\001 \001(\0132\027.abb.egm.wrapper.He"
      "ader\022+\n\010feedback\030\002 \001(\0132\031.abb.egm.wrapper"
      ".Feedback\022)\n\007planned\030\003 \001(\0132\030.abb.egm.wra"
      "pper.Planned\022\'\n\006status\030\004 \001(\0132\027.abb.egm.w"
      "rapper.Status\"\\\n\006Output\022%\n\005robot\030\001 \001(\0132\026"
      ".abb.egm.wrapper.Robot\022+\n\010external\030\002 \001(\013"
      "2\031.abb.egm.wrapper.External"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1987);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm_wrapper.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_egm_5fwrapper_2eproto
namespace abb {
namespace egm {
namespace wrapper {
const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[0];
}
bool Header_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Header_MessageType Header::UNDEFINED;
const Header_MessageType Header::DATA;
const Header_MessageType Header::MessageType_MIN;
const Header_MessageType Header::MessageType_MAX;
const int Header::MessageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[1];
}
bool Status_EGMState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_EGMState Status::EGM_UNDEFINED;
const Status_EGMState Status::EGM_ERROR;
const Status_EGMState Status::EGM_STOPPED;
const Status_EGMState Status::EGM_RUNNING;
const Status_EGMState Status::EGMState_MIN;
const Status_EGMState Status::EGMState_MAX;
const int Status::EGMState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[2];
}
bool Status_MotorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_MotorState Status::MOTORS_UNDEFINED;
const Status_MotorState Status::MOTORS_ON;
const Status_MotorState Status::MOTORS_OFF;
const Status_MotorState Status::MotorState_MIN;
const Status_MotorState Status::MotorState_MAX;
const int Status::MotorState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[3];
}
bool Status_RAPIDExecutionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_RAPIDExecutionState Status::RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status::RAPID_STOPPED;
const Status_RAPIDExecutionState Status::RAPID_RUNNING;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MIN;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MAX;
const int Status::RAPIDExecutionState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void Header::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kSequanceNumberFieldNumber;
const int Header::kTimeStampFieldNumber;
const int Header::kMessageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsHeader();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Header)
}
Header::Header(const Header& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sequance_number_, &from.sequance_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&message_type_) -
    reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Header)
}

void Header::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&sequance_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&message_type_) -
      reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Header)
  SharedDtor();
}

void Header::SharedDtor() {
}

void Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Header::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Header& Header::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsHeader();
  return *internal_default_instance();
}

Header* Header::New(::google::protobuf::Arena* arena) const {
  Header* n = new Header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&sequance_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&message_type_) -
        reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequance_number = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_sequance_number();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequance_number_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 time_stamp = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_time_stamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_MessageType_IsValid(value)) {
            set_message_type(static_cast< ::abb::egm::wrapper::Header_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequance_number = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequance_number(), output);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->message_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Header)
}

::google::protobuf::uint8* Header::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequance_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sequance_number(), target);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->message_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Header)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 sequance_number = 1;
    if (has_sequance_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequance_number());
    }

    // optional uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
    if (has_message_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  const Header* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Header>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Header)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Header)
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      sequance_number_ = from.sequance_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      time_stamp_ = from.time_stamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      message_type_ = from.message_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  using std::swap;
  swap(sequance_number_, other->sequance_number_);
  swap(time_stamp_, other->time_stamp_);
  swap(message_type_, other->message_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Header::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Status::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Status::kEgmConvergenceMetFieldNumber;
const int Status::kEgmStateFieldNumber;
const int Status::kMotorStateFieldNumber;
const int Status::kRapidExecutionStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Status::Status()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsStatus();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Status)
}
Status::Status(const Status& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&egm_convergence_met_, &from.egm_convergence_met_,
    static_cast<size_t>(reinterpret_cast<char*>(&rapid_execution_state_) -
    reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Status)
}

void Status::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rapid_execution_state_) -
      reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Status)
  SharedDtor();
}

void Status::SharedDtor() {
}

void Status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Status::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Status& Status::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsStatus();
  return *internal_default_instance();
}

Status* Status::New(::google::protobuf::Arena* arena) const {
  Status* n = new Status;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rapid_execution_state_) -
        reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Status)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool egm_convergence_met = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_egm_convergence_met();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &egm_convergence_met_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_EGMState_IsValid(value)) {
            set_egm_state(static_cast< ::abb::egm::wrapper::Status_EGMState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_MotorState_IsValid(value)) {
            set_motor_state(static_cast< ::abb::egm::wrapper::Status_MotorState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value)) {
            set_rapid_execution_state(static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Status)
  return false;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->egm_convergence_met(), output);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->egm_state(), output);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->motor_state(), output);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rapid_execution_state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Status)
}

::google::protobuf::uint8* Status::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->egm_convergence_met(), target);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->egm_state(), target);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->motor_state(), target);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rapid_execution_state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Status)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional bool egm_convergence_met = 1;
    if (has_egm_convergence_met()) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
    if (has_egm_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->egm_state());
    }

    // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
    if (has_motor_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motor_state());
    }

    // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
    if (has_rapid_execution_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rapid_execution_state());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  const Status* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Status>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Status)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Status)
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      egm_convergence_met_ = from.egm_convergence_met_;
    }
    if (cached_has_bits & 0x00000002u) {
      egm_state_ = from.egm_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      motor_state_ = from.motor_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      rapid_execution_state_ = from.rapid_execution_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::Swap(Status* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Status::InternalSwap(Status* other) {
  using std::swap;
  swap(egm_convergence_met_, other->egm_convergence_met_);
  swap(egm_state_, other->egm_state_);
  swap(motor_state_, other->motor_state_);
  swap(rapid_execution_state_, other->rapid_execution_state_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Status::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Joints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Joints::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Joints::Joints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsJoints();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Joints)
}
Joints::Joints(const Joints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      values_(from.values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Joints)
}

void Joints::SharedCtor() {
  _cached_size_ = 0;
}

Joints::~Joints() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Joints)
  SharedDtor();
}

void Joints::SharedDtor() {
}

void Joints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Joints::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Joints& Joints::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsJoints();
  return *internal_default_instance();
}

Joints* Joints::New(::google::protobuf::Arena* arena) const {
  Joints* n = new Joints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Joints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Joints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Joints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_values())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Joints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Joints)
  return false;
#undef DO_
}

void Joints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  for (int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->values(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Joints)
}

::google::protobuf::uint8* Joints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->values_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Joints)
  return target;
}

size_t Joints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Joints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->values_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->values_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Joints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  const Joints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Joints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Joints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Joints)
    MergeFrom(*source);
  }
}

void Joints::MergeFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
}

void Joints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Joints::CopyFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joints::IsInitialized() const {
  return true;
}

void Joints::Swap(Joints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Joints::InternalSwap(Joints* other) {
  using std::swap;
  values_.InternalSwap(&other->values_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Joints::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void JointSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JointSpace::kPositionFieldNumber;
const int JointSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JointSpace::JointSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsJointSpace();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.JointSpace)
}
JointSpace::JointSpace(const JointSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Joints(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::Joints(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.JointSpace)
}

void JointSpace::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&position_)) + sizeof(velocity_));
}

JointSpace::~JointSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.JointSpace)
  SharedDtor();
}

void JointSpace::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete velocity_;
}

void JointSpace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JointSpace::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const JointSpace& JointSpace::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsJointSpace();
  return *internal_default_instance();
}

JointSpace* JointSpace::New(::google::protobuf::Arena* arena) const {
  JointSpace* n = new JointSpace;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void JointSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool JointSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.JointSpace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.JointSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.JointSpace)
  return false;
#undef DO_
}

void JointSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->velocity_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.JointSpace)
}

::google::protobuf::uint8* JointSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->position_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->velocity_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.JointSpace)
  return target;
}

size_t JointSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.JointSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Joints position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->position_);
    }

    // optional .abb.egm.wrapper.Joints velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JointSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const JointSpace* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const JointSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.JointSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.JointSpace)
    MergeFrom(*source);
  }
}

void JointSpace::MergeFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Joints::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::Joints::MergeFrom(from.velocity());
    }
  }
}

void JointSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointSpace::CopyFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointSpace::IsInitialized() const {
  return true;
}

void JointSpace::Swap(JointSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JointSpace::InternalSwap(JointSpace* other) {
  using std::swap;
  swap(position_, other->position_);
  swap(velocity_, other->velocity_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata JointSpace::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Cartesian::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cartesian::kXFieldNumber;
const int Cartesian::kYFieldNumber;
const int Cartesian::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cartesian::Cartesian()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesian();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Cartesian)
}

void Cartesian::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Cartesian)
  SharedDtor();
}

void Cartesian::SharedDtor() {
}

void Cartesian::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cartesian::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Cartesian& Cartesian::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesian();
  return *internal_default_instance();
}

Cartesian* Cartesian::New(::google::protobuf::Arena* arena) const {
  Cartesian* n = new Cartesian;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Cartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Cartesian)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Cartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Cartesian)
  return false;
#undef DO_
}

void Cartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Cartesian)
}

::google::protobuf::uint8* Cartesian::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Cartesian)
  return target;
}

size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Cartesian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cartesian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  const Cartesian* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Cartesian>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Cartesian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Cartesian)
    MergeFrom(*source);
  }
}

void Cartesian::MergeFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Cartesian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  return true;
}

void Cartesian::Swap(Cartesian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Cartesian::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Euler::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Euler::kXFieldNumber;
const int Euler::kYFieldNumber;
const int Euler::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Euler::Euler()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsEuler();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Euler)
}
Euler::Euler(const Euler& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Euler)
}

void Euler::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Euler::~Euler() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Euler)
  SharedDtor();
}

void Euler::SharedDtor() {
}

void Euler::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Euler::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Euler& Euler::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsEuler();
  return *internal_default_instance();
}

Euler* Euler::New(::google::protobuf::Arena* arena) const {
  Euler* n = new Euler;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Euler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Euler)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Euler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Euler)
  return false;
#undef DO_
}

void Euler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Euler)
}

::google::protobuf::uint8* Euler::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Euler)
  return target;
}

size_t Euler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Euler)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Euler::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  const Euler* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Euler>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Euler)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Euler)
    MergeFrom(*source);
  }
}

void Euler::MergeFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Euler::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Euler::CopyFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Euler::IsInitialized() const {
  return true;
}

void Euler::Swap(Euler* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Euler::InternalSwap(Euler* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Euler::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Quaternion::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kU0FieldNumber;
const int Quaternion::kU1FieldNumber;
const int Quaternion::kU2FieldNumber;
const int Quaternion::kU3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsQuaternion();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&u0_, &from.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
    reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Quaternion)
}

void Quaternion::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&u0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&u3_) -
      reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
}

void Quaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Quaternion::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Quaternion& Quaternion::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsQuaternion();
  return *internal_default_instance();
}

Quaternion* Quaternion::New(::google::protobuf::Arena* arena) const {
  Quaternion* n = new Quaternion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u3_) -
        reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Quaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double u0 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_u0();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_u1();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u2 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_u2();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u3 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u /* 33 & 0xFF */)) {
          set_has_u3();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Quaternion)
  return false;
#undef DO_
}

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Quaternion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional double u0 = 1;
    if (has_u0()) {
      total_size += 1 + 8;
    }

    // optional double u1 = 2;
    if (has_u1()) {
      total_size += 1 + 8;
    }

    // optional double u2 = 3;
    if (has_u2()) {
      total_size += 1 + 8;
    }

    // optional double u3 = 4;
    if (has_u3()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const Quaternion* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Quaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      u0_ = from.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      u1_ = from.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      u2_ = from.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      u3_ = from.u3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  swap(u0_, other->u0_);
  swap(u1_, other->u1_);
  swap(u2_, other->u2_);
  swap(u3_, other->u3_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianPose::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->euler_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->quaternion_ = const_cast< ::abb::egm::wrapper::Quaternion*>(
      ::abb::egm::wrapper::Quaternion::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianPose::kPositionFieldNumber;
const int CartesianPose::kEulerFieldNumber;
const int CartesianPose::kQuaternionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianPose::CartesianPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianPose();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianPose)
}
CartesianPose::CartesianPose(const CartesianPose& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Cartesian(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_euler()) {
    euler_ = new ::abb::egm::wrapper::Euler(*from.euler_);
  } else {
    euler_ = NULL;
  }
  if (from.has_quaternion()) {
    quaternion_ = new ::abb::egm::wrapper::Quaternion(*from.quaternion_);
  } else {
    quaternion_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianPose)
}

void CartesianPose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quaternion_) -
      reinterpret_cast<char*>(&position_)) + sizeof(quaternion_));
}

CartesianPose::~CartesianPose() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianPose)
  SharedDtor();
}

void CartesianPose::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete euler_;
  if (this != internal_default_instance()) delete quaternion_;
}

void CartesianPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianPose::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianPose& CartesianPose::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianPose();
  return *internal_default_instance();
}

CartesianPose* CartesianPose::New(::google::protobuf::Arena* arena) const {
  CartesianPose* n = new CartesianPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CartesianPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(euler_ != NULL);
      euler_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(quaternion_ != NULL);
      quaternion_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler euler = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Quaternion quaternion = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_quaternion()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianPose)
  return false;
#undef DO_
}

void CartesianPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->euler_, output);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->quaternion_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianPose)
}

::google::protobuf::uint8* CartesianPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->position_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->euler_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->quaternion_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianPose)
  return target;
}

size_t CartesianPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianPose)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.wrapper.Cartesian position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->position_);
    }

    // optional .abb.egm.wrapper.Euler euler = 2;
    if (has_euler()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->euler_);
    }

    // optional .abb.egm.wrapper.Quaternion quaternion = 3;
    if (has_quaternion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->quaternion_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianPose* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianPose)
    MergeFrom(*source);
  }
}

void CartesianPose::MergeFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Cartesian::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_euler()->::abb::egm::wrapper::Euler::MergeFrom(from.euler());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_quaternion()->::abb::egm::wrapper::Quaternion::MergeFrom(from.quaternion());
    }
  }
}

void CartesianPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianPose::CopyFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianPose::IsInitialized() const {
  return true;
}

void CartesianPose::Swap(CartesianPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianPose::InternalSwap(CartesianPose* other) {
  using std::swap;
  swap(position_, other->position_);
  swap(euler_, other->euler_);
  swap(quaternion_, other->quaternion_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CartesianPose::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianVelocity::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->linear_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->angular_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianVelocity::kLinearFieldNumber;
const int CartesianVelocity::kAngularFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianVelocity::CartesianVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianVelocity();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianVelocity)
}
CartesianVelocity::CartesianVelocity(const CartesianVelocity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_linear()) {
    linear_ = new ::abb::egm::wrapper::Cartesian(*from.linear_);
  } else {
    linear_ = NULL;
  }
  if (from.has_angular()) {
    angular_ = new ::abb::egm::wrapper::Euler(*from.angular_);
  } else {
    angular_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianVelocity)
}

void CartesianVelocity::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&linear_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&angular_) -
      reinterpret_cast<char*>(&linear_)) + sizeof(angular_));
}

CartesianVelocity::~CartesianVelocity() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianVelocity)
  SharedDtor();
}

void CartesianVelocity::SharedDtor() {
  if (this != internal_default_instance()) delete linear_;
  if (this != internal_default_instance()) delete angular_;
}

void CartesianVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianVelocity::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianVelocity& CartesianVelocity::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianVelocity();
  return *internal_default_instance();
}

CartesianVelocity* CartesianVelocity::New(::google::protobuf::Arena* arena) const {
  CartesianVelocity* n = new CartesianVelocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CartesianVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(linear_ != NULL);
      linear_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angular_ != NULL);
      angular_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian linear = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_linear()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler angular = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angular()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianVelocity)
  return false;
#undef DO_
}

void CartesianVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->linear_, output);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angular_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianVelocity)
}

::google::protobuf::uint8* CartesianVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->linear_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->angular_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianVelocity)
  return target;
}

size_t CartesianVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianVelocity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Cartesian linear = 1;
    if (has_linear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->linear_);
    }

    // optional .abb.egm.wrapper.Euler angular = 2;
    if (has_angular()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->angular_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianVelocity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianVelocity)
    MergeFrom(*source);
  }
}

void CartesianVelocity::MergeFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_linear()->::abb::egm::wrapper::Cartesian::MergeFrom(from.linear());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angular()->::abb::egm::wrapper::Euler::MergeFrom(from.angular());
    }
  }
}

void CartesianVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianVelocity::CopyFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianVelocity::IsInitialized() const {
  return true;
}

void CartesianVelocity::Swap(CartesianVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianVelocity::InternalSwap(CartesianVelocity* other) {
  using std::swap;
  swap(linear_, other->linear_);
  swap(angular_, other->angular_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CartesianVelocity::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->pose_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(
      ::abb::egm::wrapper::CartesianPose::internal_default_instance());
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::CartesianVelocity*>(
      ::abb::egm::wrapper::CartesianVelocity::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianSpace::kPoseFieldNumber;
const int CartesianSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianSpace::CartesianSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianSpace();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianSpace)
}
CartesianSpace::CartesianSpace(const CartesianSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pose()) {
    pose_ = new ::abb::egm::wrapper::CartesianPose(*from.pose_);
  } else {
    pose_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::CartesianVelocity(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianSpace)
}

void CartesianSpace::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(velocity_));
}

CartesianSpace::~CartesianSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianSpace)
  SharedDtor();
}

void CartesianSpace::SharedDtor() {
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete velocity_;
}

void CartesianSpace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianSpace::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianSpace& CartesianSpace::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsCartesianSpace();
  return *internal_default_instance();
}

CartesianSpace* CartesianSpace::New(::google::protobuf::Arena* arena) const {
  CartesianSpace* n = new CartesianSpace;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CartesianSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pose_ != NULL);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianSpace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianSpace)
  return false;
#undef DO_
}

void CartesianSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pose_, output);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->velocity_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianSpace)
}

::google::protobuf::uint8* CartesianSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->pose_, deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->velocity_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianSpace)
  return target;
}

size_t CartesianSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.CartesianPose pose = 1;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->pose_);
    }

    // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianSpace* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianSpace)
    MergeFrom(*source);
  }
}

void CartesianSpace::MergeFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pose()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.pose());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::CartesianVelocity::MergeFrom(from.velocity());
    }
  }
}

void CartesianSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianSpace::CopyFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianSpace::IsInitialized() const {
  return true;
}

void CartesianSpace::Swap(CartesianSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianSpace::InternalSwap(CartesianSpace* other) {
  using std::swap;
  swap(pose_, other->pose_);
  swap(velocity_, other->velocity_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CartesianSpace::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Robot::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->cartesian_ = const_cast< ::abb::egm::wrapper::CartesianSpace*>(
      ::abb::egm::wrapper::CartesianSpace::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Robot::kJointsFieldNumber;
const int Robot::kCartesianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Robot::Robot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsRobot();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Robot)
}
Robot::Robot(const Robot& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesian()) {
    cartesian_ = new ::abb::egm::wrapper::CartesianSpace(*from.cartesian_);
  } else {
    cartesian_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Robot)
}

void Robot::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cartesian_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(cartesian_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Robot)
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
}

void Robot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Robot::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Robot& Robot::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsRobot();
  return *internal_default_instance();
}

Robot* Robot::New(::google::protobuf::Arena* arena) const {
  Robot* n = new Robot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != NULL);
      cartesian_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Robot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Robot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Robot)
  return false;
#undef DO_
}

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->joints_, output);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cartesian_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Robot)
}

::google::protobuf::uint8* Robot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->joints_, deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->cartesian_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Robot)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.JointSpace joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->joints_);
    }

    // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->cartesian_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  const Robot* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Robot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Robot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Robot)
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianSpace::MergeFrom(from.cartesian());
    }
  }
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::Swap(Robot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Robot::InternalSwap(Robot* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(cartesian_, other->cartesian_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Robot::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void External::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_External_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int External::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

External::External()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsExternal();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.External)
}
External::External(const External& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.External)
}

void External::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
}

External::~External() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.External)
  SharedDtor();
}

void External::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
}

void External::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* External::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const External& External::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsExternal();
  return *internal_default_instance();
}

External* External::New(::google::protobuf::Arena* arena) const {
  External* n = new External;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void External::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(joints_ != NULL);
    joints_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool External::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.External)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.External)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.External)
  return false;
#undef DO_
}

void External::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->joints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.External)
}

::google::protobuf::uint8* External::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->joints_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.External)
  return target;
}

size_t External::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.External)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->joints_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void External::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  const External* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const External>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.External)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.External)
    MergeFrom(*source);
  }
}

void External::MergeFrom(const External& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_joints()) {
    mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
  }
}

void External::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void External::CopyFrom(const External& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool External::IsInitialized() const {
  return true;
}

void External::Swap(External* other) {
  if (other == this) return;
  InternalSwap(other);
}
void External::InternalSwap(External* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata External::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Feedback::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Feedback::kRobotFieldNumber;
const int Feedback::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Feedback::Feedback()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsFeedback();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Feedback)
}
Feedback::Feedback(const Feedback& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Feedback)
}

void Feedback::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Feedback::~Feedback() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Feedback)
  SharedDtor();
}

void Feedback::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Feedback::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Feedback::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Feedback& Feedback::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsFeedback();
  return *internal_default_instance();
}

Feedback* Feedback::New(::google::protobuf::Arena* arena) const {
  Feedback* n = new Feedback;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Feedback::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Feedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Feedback)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Feedback)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Feedback)
  return false;
#undef DO_
}

void Feedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->robot_, output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->external_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Feedback)
}

::google::protobuf::uint8* Feedback::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->robot_, deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->external_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Feedback)
  return target;
}

size_t Feedback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Feedback)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Feedback::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  const Feedback* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Feedback>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Feedback)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Feedback)
    MergeFrom(*source);
  }
}

void Feedback::MergeFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Feedback::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Feedback::CopyFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Feedback::IsInitialized() const {
  return true;
}

void Feedback::Swap(Feedback* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Feedback::InternalSwap(Feedback* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Feedback::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Planned::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Planned::kRobotFieldNumber;
const int Planned::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Planned::Planned()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsPlanned();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Planned)
}
Planned::Planned(const Planned& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Planned)
}

void Planned::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Planned::~Planned() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Planned)
  SharedDtor();
}

void Planned::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Planned::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Planned::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Planned& Planned::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsPlanned();
  return *internal_default_instance();
}

Planned* Planned::New(::google::protobuf::Arena* arena) const {
  Planned* n = new Planned;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Planned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Planned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Planned)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Planned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Planned)
  return false;
#undef DO_
}

void Planned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->robot_, output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->external_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Planned)
}

::google::protobuf::uint8* Planned::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->robot_, deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->external_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Planned)
  return target;
}

size_t Planned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Planned)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Planned::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  const Planned* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Planned>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Planned)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Planned)
    MergeFrom(*source);
  }
}

void Planned::MergeFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Planned::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Planned::CopyFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Planned::IsInitialized() const {
  return true;
}

void Planned::Swap(Planned* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Planned::InternalSwap(Planned* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Planned::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Input::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::wrapper::Header*>(
      ::abb::egm::wrapper::Header::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->feedback_ = const_cast< ::abb::egm::wrapper::Feedback*>(
      ::abb::egm::wrapper::Feedback::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->planned_ = const_cast< ::abb::egm::wrapper::Planned*>(
      ::abb::egm::wrapper::Planned::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->status_ = const_cast< ::abb::egm::wrapper::Status*>(
      ::abb::egm::wrapper::Status::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Input::kHeaderFieldNumber;
const int Input::kFeedbackFieldNumber;
const int Input::kPlannedFieldNumber;
const int Input::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Input::Input()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsInput();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Input)
}
Input::Input(const Input& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::wrapper::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_feedback()) {
    feedback_ = new ::abb::egm::wrapper::Feedback(*from.feedback_);
  } else {
    feedback_ = NULL;
  }
  if (from.has_planned()) {
    planned_ = new ::abb::egm::wrapper::Planned(*from.planned_);
  } else {
    planned_ = NULL;
  }
  if (from.has_status()) {
    status_ = new ::abb::egm::wrapper::Status(*from.status_);
  } else {
    status_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Input)
}

void Input::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

Input::~Input() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Input)
  SharedDtor();
}

void Input::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete feedback_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete status_;
}

void Input::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Input::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Input& Input::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsInput();
  return *internal_default_instance();
}

Input* Input::New(::google::protobuf::Arena* arena) const {
  Input* n = new Input;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Input::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feedback_ != NULL);
      feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(planned_ != NULL);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(status_ != NULL);
      status_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Input)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Feedback feedback = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Planned planned = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status status = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Input)
  return false;
#undef DO_
}

void Input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->feedback_, output);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->planned_, output);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->status_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Input)
}

::google::protobuf::uint8* Input::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->feedback_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->planned_, deterministic, target);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, *this->status_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Input)
  return target;
}

size_t Input::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Input)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional .abb.egm.wrapper.Header header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->header_);
    }

    // optional .abb.egm.wrapper.Feedback feedback = 2;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->feedback_);
    }

    // optional .abb.egm.wrapper.Planned planned = 3;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->planned_);
    }

    // optional .abb.egm.wrapper.Status status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->status_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Input::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  const Input* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Input>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Input)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Input)
    MergeFrom(*source);
  }
}

void Input::MergeFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::wrapper::Header::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_feedback()->::abb::egm::wrapper::Feedback::MergeFrom(from.feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_planned()->::abb::egm::wrapper::Planned::MergeFrom(from.planned());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_status()->::abb::egm::wrapper::Status::MergeFrom(from.status());
    }
  }
}

void Input::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Input::CopyFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Input::IsInitialized() const {
  return true;
}

void Input::Swap(Input* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Input::InternalSwap(Input* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(feedback_, other->feedback_);
  swap(planned_, other->planned_);
  swap(status_, other->status_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Input::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Output::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Output::kRobotFieldNumber;
const int Output::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Output::Output()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_5fwrapper_2eproto::InitDefaultsOutput();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Output)
}
Output::Output(const Output& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Output)
}

void Output::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Output::~Output() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Output)
  SharedDtor();
}

void Output::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Output::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Output::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Output& Output::default_instance() {
  ::protobuf_egm_5fwrapper_2eproto::InitDefaultsOutput();
  return *internal_default_instance();
}

Output* Output::New(::google::protobuf::Arena* arena) const {
  Output* n = new Output;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Output::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Output)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Output)
  return false;
#undef DO_
}

void Output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->robot_, output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->external_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Output)
}

::google::protobuf::uint8* Output::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->robot_, deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->external_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Output)
  return target;
}

size_t Output::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Output)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Output::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  const Output* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Output>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Output)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Output)
    MergeFrom(*source);
  }
}

void Output::MergeFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Output::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Output::CopyFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Output::IsInitialized() const {
  return true;
}

void Output::Swap(Output* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Output::InternalSwap(Output* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Output::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace wrapper
}  // namespace egm
}  // namespace abb

// @@protoc_insertion_point(global_scope)
